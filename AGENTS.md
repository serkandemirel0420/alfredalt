# AlfredAlternative - Agent Guide

## Project Overview

AlfredAlternative is a macOS launcher application that provides fast search and note-taking capabilities. It is a hybrid application combining a Rust backend (for data storage and search) with a Swift/SwiftUI frontend (for the native macOS UI).

The app features:
- Full-text search powered by Tantivy (Lucene-inspired search engine)
- Note editor with inline image support (drag, resize, reorder)
- Global hotkey (Command+Space) activation
- JSON-based data storage with configurable storage path
- Automatic update checking via GitHub releases

## Technology Stack

| Component | Technology |
|-----------|------------|
| Backend Language | Rust (Edition 2024) |
| Frontend Language | Swift with SwiftUI |
| FFI Bridge | UniFFI 0.29 |
| Search Engine | Tantivy 0.22 |
| Data Storage | JSON files + Lucene index |
| Build Tools | Cargo, Make, swiftc |

### Key Rust Dependencies

- `tantivy` - Full-text search engine
- `serde` / `serde_json` - Serialization
- `anyhow` / `thiserror` - Error handling
- `directories` - XDG-compliant data directories
- `uniffi` - Swift bindings generation

## Project Structure

```
.
├── Cargo.toml              # Rust project configuration
├── Cargo.lock              # Dependency lock file
├── Makefile                # Build orchestration
├── entitlements.plist      # macOS entitlements for codesigning
├── scripts/
│   ├── generate_swift_bridge.sh   # Build Rust lib + generate Swift bindings
│   └── release.sh                 # Build DMG and create GitHub release
├── src/
│   ├── lib.rs              # Library entry point (UniFFI scaffolding)
│   ├── main.rs             # CLI placeholder (not used by app)
│   ├── backend.rs          # FFI-exported functions for Swift
│   ├── db.rs               # Data storage, indexing, and search logic
│   ├── models.rs           # Internal data models
│   └── bin/uniffi_swift_bindgen.rs  # UniFFI binding generator
├── swift/
│   ├── App/                # SwiftUI application code
│   │   ├── AlfredAlternativeApp.swift    # App entry point & AppDelegate
│   │   ├── ContentView.swift             # Main launcher UI + editor
│   │   ├── LauncherViewModel.swift       # View model for launcher/editor
│   │   ├── RustBridgeClient.swift        # Rust FFI wrapper
│   │   ├── GlobalHotKeyMonitor.swift     # Cmd+Space hotkey (Carbon API)
│   │   ├── InlineImageTextEditor.swift   # Custom NSTextView with images
│   │   ├── KeyEventMonitor.swift         # Keyboard event handling
│   │   ├── WindowConfigurator.swift      # Window styling
│   │   └── UpdateChecker.swift           # GitHub release checking
│   └── RustBridge/
│       └── Generated/      # Auto-generated by UniFFI
│           ├── alfred_alt.swift
│           ├── alfred_altFFI.h
│           └── alfred_alt.modulemap
├── resources/
│   └── AppIcon.icns        # Application icon
└── .build/
    └── AlfredAlternative.app   # Generated app bundle
```

## Build Commands

### Prerequisites

- macOS 13.0+ (Apple Silicon optimized, Intel compatible)
- Rust toolchain with targets: `aarch64-apple-darwin`, `x86_64-apple-darwin`
- Xcode Command Line Tools (for swiftc)
- `gh` CLI tool (for releases only)

Install Rust targets:
```bash
rustup target add aarch64-apple-darwin x86_64-apple-darwin
```

### Development Build

Generate Swift bridge files and build the Rust library:
```bash
./scripts/generate_swift_bridge.sh
```

This creates:
- `swift/RustBridge/lib/libalfred_alt_host.a` - Host architecture static library
- `swift/RustBridge/lib/libalfred_alt_universal.a` - Universal binary (if both targets available)
- `swift/RustBridge/Generated/*.swift` - Swift FFI bindings

Build the macOS app bundle:
```bash
make build-app
```

### Running the App

Run the app bundle:
```bash
make run
```

Run the binary directly (for debugging):
```bash
make run-cli
```

### Release Build

Create a signed DMG and publish to GitHub:
```bash
make release
```

This:
1. Builds the app bundle
2. Creates a DMG in `.build/AlfredAlternative-{version}.dmg`
3. Creates/updates a GitHub release with the DMG attached

## Code Organization

### Rust Backend (`src/`)

| File | Purpose |
|------|---------|
| `lib.rs` | Exports modules and initializes UniFFI scaffolding |
| `backend.rs` | FFI-exported functions (annotated with `#[uniffi::export]`) that Swift calls |
| `db.rs` | Core logic: Lucene index management, data persistence, search algorithms |
| `models.rs` | Internal structs: `SearchResult`, `NoteImage`, `EditableItem` |

Key data flow:
1. Swift calls `RustBridgeClient.search(query:)` 
2. This invokes the UniFFI-generated `searchItems()` which calls Rust
3. `backend.rs::search_items()` validates input and calls `db.rs::search()`
4. `db.rs` queries the Tantivy index and falls back to substring/fuzzy search
5. Results are converted to `SearchResultRecord` and returned to Swift

### Swift Frontend (`swift/App/`)

| File | Purpose |
|------|---------|
| `AlfredAlternativeApp.swift` | `App` protocol implementation, `AppDelegate` for hotkey registration |
| `ContentView.swift` | Launcher window UI (search field, results list, action menu) + Editor window |
| `LauncherViewModel.swift` | Observable object managing app state, search, editor, and persistence |
| `RustBridgeClient.swift` | Thin wrapper around UniFFI-generated bindings |
| `InlineImageTextEditor.swift` | Custom `NSTextView` subclass supporting inline images with resize/move |
| `GlobalHotKeyMonitor.swift` | Carbon API-based global Command+Space hotkey |

## Storage Architecture

### Lucene Index

- Location: `~/Library/Application Support/com.Codex.alfred_alt/alfred_lucene_index/`
- Stores all items and settings as Tantivy documents
- Supports full-text search with stemming and snippet generation

### JSON Storage

- Default location: `~/Documents/AlfredAlternativeData/`
- Each item saved as `item-{id}.json`
- Images saved as binary files in `images/` subdirectory
- Configurable via Settings panel

### Data Model

```rust
struct PersistedItem {
    id: i64,
    title: String,
    subtitle: String,
    keywords: String,
    note: String,
    images: Vec<PersistedImage>,
}
```

Images are referenced in notes using Markdown-like syntax:
```
![image](alfred://image/{image_key}?w=360)
```

## Search Algorithm

The search implementation in `db.rs` uses a three-tier approach:

1. **Lucene Search**: Fast prefix search with snippet generation
2. **Substring Fallback**: Case-insensitive substring matching for unmatched queries
3. **Fuzzy Search**: Bigram Dice similarity for typo tolerance (terms >= 4 chars)

Search result snippets use `**term**` markdown-style highlighting.

## Testing

Run Rust unit tests:
```bash
cargo test
```

Tests cover:
- Snippet generation and highlighting
- Fuzzy similarity scoring
- Note sanitization (image ref removal)

## Key Conventions

### Error Handling

- **Rust**: Uses `anyhow::Result` internally, maps to `BackendError` enum for FFI
- **Swift**: `RustBridgeClient` methods `throw` Swift errors converted from `BackendError`

### Image Handling

- Maximum 24 images per item (`MAX_NOTE_IMAGE_COUNT`)
- Maximum 12MB per image (`MAX_SCREENSHOT_BYTES`)
- Images are inlined in the note text using custom URL scheme `alfred://image/`

### Keyboard Shortcuts

| Shortcut | Action |
|----------|--------|
| Command+Space | Toggle launcher visibility (global) |
| Enter | Open selected item / Create new item |
| Command (tap) | Open action menu on selected item |
| Escape | Dismiss launcher / Close action menu |
| Command +/- | Increase/decrease editor font size |
| Command+V | Paste image from clipboard (in editor) |

## Security Considerations

- The app is not notarized; users must bypass Gatekeeper or run the fix script
- `entitlements.plist` grants `com.apple.security.get-task-allow` for debugging
- JSON storage path expansion supports `~` for home directory

## Version Management

- Single source of truth: `Cargo.toml` `version` field
- GitHub releases use `v{version}` tag format
- Swift `UpdateChecker` queries GitHub API for newer versions

## Common Tasks

### Adding a New Backend Function

1. Add function to `src/backend.rs` with `#[uniffi::export]`
2. Add to `src/models.rs` if new data types needed
3. Regenerate bridge: `./scripts/generate_swift_bridge.sh`
4. Add wrapper in `swift/App/RustBridgeClient.swift`
5. Use in Swift UI code

### Modifying the Search Index Schema

The schema is defined in `db.rs` `build_index_schema()`. Changing fields requires:
1. Incrementing index version logic (or clearing user indexes)
2. Rebuilding the index on next launch

### Updating App Icons

Replace `resources/AppIcon.icns` and rebuild.
